diff --git a/src/solver/Deadlock.java b/src/solver/Deadlock.java
index c5714a9..07cbe8d 100644
--- a/src/solver/Deadlock.java
+++ b/src/solver/Deadlock.java
@@ -31,28 +31,35 @@ public final class Deadlock {
     }
 
     public boolean isDeadlock(State state) {
-        markBoxes(state);
-        for (Coordinate box : state.getBoxes()) {
-            if (isGoal(box.x, box.y)) {
-                continue;
-            }
-            if (isCorner(box.x, box.y)) {
-                return true;
-            }
-            if (isFrozenSquare(box.x, box.y)) {
-                return true;
-            }
-            if (!regionHasGoalIgnoringBoxes(box.x, box.y)) {
-                return true;
-            }
-            if (isCorridorTrap(box)) {
-                return true;
+        long start = Diagnostics.now();
+        try {
+            markBoxes(state);
+            for (Coordinate box : state.getBoxes()) {
+                if (isGoal(box.x, box.y)) {
+                    continue;
+                }
+                if (isCorner(box.x, box.y)) {
+                    return true;
+                }
+                if (isFrozenSquare(box.x, box.y)) {
+                    return true;
+                }
+                if (!regionHasGoalIgnoringBoxes(box.x, box.y)) {
+                    return true;
+                }
+                if (isCorridorTrap(box)) {
+                    return true;
+                }
+                if (isImmovable(box.x, box.y, state.getBoxes())) {
+                    return true;
+                }
             }
-            if (isImmovable(box.x, box.y, state.getBoxes())) {
-                return true;
+            return false;
+        } finally {
+            if (Diagnostics.ENABLED) {
+                Diagnostics.recordDeadlockCheckTime(System.nanoTime() - start);
             }
         }
-        return false;
     }
 
     private void markBoxes(State state) {
@@ -184,110 +191,124 @@ public final class Deadlock {
     }
 
     public boolean regionHasGoalForMove(Coordinate[] boxes, int movedIdx, int destX, int destY) {
-        if (!inBounds(destX, destY)) {
-            return false;
-        }
-        if (mapData[destY][destX] == Constants.WALL) {
-            return false;
-        }
-
-        advanceRegionToken();
-        advanceOccupiedToken();
-        int ignoringToken = regionToken;
-        Queue<int[]> queue = new ArrayDeque<>();
-        for (int i = 0; i < boxes.length; i++) {
-            if (i == movedIdx) {
-                continue;
-            }
-            Coordinate other = boxes[i];
-            if (other != null && inBounds(other.x, other.y)) {
-                occupiedStamp[other.y][other.x] = occupiedToken;
+        long start = Diagnostics.now();
+        try {
+            if (!inBounds(destX, destY)) {
+                return false;
             }
-        }
-        regionStamp[destY][destX] = ignoringToken;
-        queue.add(new int[] {destX, destY});
-        int goalsInRegion = 0;
-        while (!queue.isEmpty()) {
-            int[] cell = queue.remove();
-            int cx = cell[0];
-            int cy = cell[1];
-            if (goal[cy][cx]) {
-                goalsInRegion++;
+            if (mapData[destY][destX] == Constants.WALL) {
+                return false;
             }
-            for (int dir = 0; dir < Constants.DIRECTION_X.length; dir++) {
-                int nx = cx + Constants.DIRECTION_X[dir];
-                int ny = cy + Constants.DIRECTION_Y[dir];
-                if (!inBounds(nx, ny)) {
+
+            advanceRegionToken();
+            advanceOccupiedToken();
+            int ignoringToken = regionToken;
+            Queue<int[]> queue = new ArrayDeque<>();
+            for (int i = 0; i < boxes.length; i++) {
+                if (i == movedIdx) {
                     continue;
                 }
-                if (regionStamp[ny][nx] == ignoringToken) {
-                    continue;
+                Coordinate other = boxes[i];
+                if (other != null && inBounds(other.x, other.y)) {
+                    occupiedStamp[other.y][other.x] = occupiedToken;
                 }
-                if (mapData[ny][nx] == Constants.WALL) {
-                    continue;
+            }
+            regionStamp[destY][destX] = ignoringToken;
+            queue.add(new int[] {destX, destY});
+            int goalsInRegion = 0;
+            while (!queue.isEmpty()) {
+                int[] cell = queue.remove();
+                int cx = cell[0];
+                int cy = cell[1];
+                if (goal[cy][cx]) {
+                    goalsInRegion++;
                 }
-                if (occupiedStamp[ny][nx] == occupiedToken) {
-                    continue;
+                for (int dir = 0; dir < Constants.DIRECTION_X.length; dir++) {
+                    int nx = cx + Constants.DIRECTION_X[dir];
+                    int ny = cy + Constants.DIRECTION_Y[dir];
+                    if (!inBounds(nx, ny)) {
+                        continue;
+                    }
+                    if (regionStamp[ny][nx] == ignoringToken) {
+                        continue;
+                    }
+                    if (mapData[ny][nx] == Constants.WALL) {
+                        continue;
+                    }
+                    if (occupiedStamp[ny][nx] == occupiedToken) {
+                        continue;
+                    }
+                    regionStamp[ny][nx] = ignoringToken;
+                    queue.add(new int[] {nx, ny});
                 }
-                regionStamp[ny][nx] = ignoringToken;
-                queue.add(new int[] {nx, ny});
             }
-        }
-        if (goalsInRegion == 0) {
-            return false;
-        }
-
-        int boxesInRegion = 0;
-        if (regionStamp[destY][destX] == ignoringToken) {
-            boxesInRegion++;
-        }
-        for (int i = 0; i < boxes.length; i++) {
-            if (i == movedIdx) {
-                continue;
+            if (goalsInRegion == 0) {
+                return false;
             }
-            Coordinate box = boxes[i];
-            if (box != null && inBounds(box.x, box.y)
-                    && regionStamp[box.y][box.x] == ignoringToken) {
+
+            int boxesInRegion = 0;
+            if (regionStamp[destY][destX] == ignoringToken) {
                 boxesInRegion++;
             }
+            for (int i = 0; i < boxes.length; i++) {
+                if (i == movedIdx) {
+                    continue;
+                }
+                Coordinate box = boxes[i];
+                if (box != null && inBounds(box.x, box.y)
+                        && regionStamp[box.y][box.x] == ignoringToken) {
+                    boxesInRegion++;
+                }
+            }
+            return boxesInRegion <= goalsInRegion;
+        } finally {
+            if (Diagnostics.ENABLED) {
+                Diagnostics.recordDeadlockRegionTime(System.nanoTime() - start);
+            }
         }
-        return boxesInRegion <= goalsInRegion;
     }
 
     public boolean isWallLineFreeze(int x, int y, Coordinate[] boxes) {
-        if (!inBounds(x, y)) {
-            return false;
-        }
-        if (isGoal(x, y)) {
-            return false;
-        }
-        int movedIdx = findBoxIndex(boxes, x, y);
-        if (movedIdx < 0) {
-            return false;
-        }
+        long start = Diagnostics.now();
+        try {
+            if (!inBounds(x, y)) {
+                return false;
+            }
+            if (isGoal(x, y)) {
+                return false;
+            }
+            int movedIdx = findBoxIndex(boxes, x, y);
+            if (movedIdx < 0) {
+                return false;
+            }
 
-        boolean verticalAlignment = false;
-        if (isWallOrOutOfBounds(x - 1, y)) {
-            verticalAlignment |= isVerticalLineBlocked(x, y, boxes, movedIdx, -1);
-        }
-        if (!verticalAlignment && isWallOrOutOfBounds(x + 1, y)) {
-            verticalAlignment |= isVerticalLineBlocked(x, y, boxes, movedIdx, 1);
-        }
-        if (verticalAlignment && !regionHasGoalForMove(boxes, movedIdx, x, y)) {
-            return true;
-        }
+            boolean verticalAlignment = false;
+            if (isWallOrOutOfBounds(x - 1, y)) {
+                verticalAlignment |= isVerticalLineBlocked(x, y, boxes, movedIdx, -1);
+            }
+            if (!verticalAlignment && isWallOrOutOfBounds(x + 1, y)) {
+                verticalAlignment |= isVerticalLineBlocked(x, y, boxes, movedIdx, 1);
+            }
+            if (verticalAlignment && !regionHasGoalForMove(boxes, movedIdx, x, y)) {
+                return true;
+            }
 
-        boolean horizontalAlignment = false;
-        if (isWallOrOutOfBounds(x, y - 1)) {
-            horizontalAlignment |= isHorizontalLineBlocked(x, y, boxes, movedIdx, -1);
-        }
-        if (!horizontalAlignment && isWallOrOutOfBounds(x, y + 1)) {
-            horizontalAlignment |= isHorizontalLineBlocked(x, y, boxes, movedIdx, 1);
-        }
-        if (horizontalAlignment && !regionHasGoalForMove(boxes, movedIdx, x, y)) {
-            return true;
+            boolean horizontalAlignment = false;
+            if (isWallOrOutOfBounds(x, y - 1)) {
+                horizontalAlignment |= isHorizontalLineBlocked(x, y, boxes, movedIdx, -1);
+            }
+            if (!horizontalAlignment && isWallOrOutOfBounds(x, y + 1)) {
+                horizontalAlignment |= isHorizontalLineBlocked(x, y, boxes, movedIdx, 1);
+            }
+            if (horizontalAlignment && !regionHasGoalForMove(boxes, movedIdx, x, y)) {
+                return true;
+            }
+            return false;
+        } finally {
+            if (Diagnostics.ENABLED) {
+                Diagnostics.recordDeadlockFreezeTime(System.nanoTime() - start);
+            }
         }
-        return false;
     }
 
     private boolean isVerticalLineBlocked(int x, int y, Coordinate[] boxes, int movedIdx, int wallDx) {
@@ -400,34 +421,41 @@ public final class Deadlock {
     }
 
     public boolean regionHasGoalIgnoringBoxes(int startX, int startY) {
-        advanceRegionToken();
-        Queue<int[]> queue = new ArrayDeque<>();
-        regionStamp[startY][startX] = regionToken;
-        queue.add(new int[] {startX, startY});
-        while (!queue.isEmpty()) {
-            int[] cell = queue.remove();
-            int cx = cell[0];
-            int cy = cell[1];
-            if (goal[cy][cx]) {
-                return true;
-            }
-            for (int dir = 0; dir < Constants.DIRECTION_X.length; dir++) {
-                int nx = cx + Constants.DIRECTION_X[dir];
-                int ny = cy + Constants.DIRECTION_Y[dir];
-                if (!inBounds(nx, ny)) {
-                    continue;
+        long start = Diagnostics.now();
+        try {
+            advanceRegionToken();
+            Queue<int[]> queue = new ArrayDeque<>();
+            regionStamp[startY][startX] = regionToken;
+            queue.add(new int[] {startX, startY});
+            while (!queue.isEmpty()) {
+                int[] cell = queue.remove();
+                int cx = cell[0];
+                int cy = cell[1];
+                if (goal[cy][cx]) {
+                    return true;
                 }
-                if (regionStamp[ny][nx] == regionToken) {
-                    continue;
+                for (int dir = 0; dir < Constants.DIRECTION_X.length; dir++) {
+                    int nx = cx + Constants.DIRECTION_X[dir];
+                    int ny = cy + Constants.DIRECTION_Y[dir];
+                    if (!inBounds(nx, ny)) {
+                        continue;
+                    }
+                    if (regionStamp[ny][nx] == regionToken) {
+                        continue;
+                    }
+                    if (mapData[ny][nx] == Constants.WALL) {
+                        continue;
+                    }
+                    regionStamp[ny][nx] = regionToken;
+                    queue.add(new int[] {nx, ny});
                 }
-                if (mapData[ny][nx] == Constants.WALL) {
-                    continue;
-                }
-                regionStamp[ny][nx] = regionToken;
-                queue.add(new int[] {nx, ny});
+            }
+            return false;
+        } finally {
+            if (Diagnostics.ENABLED) {
+                Diagnostics.recordDeadlockLooseTime(System.nanoTime() - start);
             }
         }
-        return false;
     }
 
     private boolean regionHasGoal(Coordinate startBox) {
diff --git a/src/solver/GBFS.java b/src/solver/GBFS.java
index 1334e86..cb1c2ca 100644
--- a/src/solver/GBFS.java
+++ b/src/solver/GBFS.java
@@ -37,14 +37,17 @@ public final class GBFS {
         }
         cmp = Integer.compare(a.getHeuristic(), b.getHeuristic());
         if (cmp != 0) {
+            Diagnostics.recordComparatorDecision("heuristic");
             return cmp;
         }
         cmp = Integer.compare(a.getPushes(), b.getPushes());
         if (cmp != 0) {
+            Diagnostics.recordComparatorDecision("pushes");
             return cmp;
         }
         cmp = Integer.compare(a.getDepth(), b.getDepth());
         if (cmp != 0) {
+            Diagnostics.recordComparatorDecision("depth");
             return cmp;
         }
         cmp = Character.compare(a.getLastMove(), b.getLastMove());
@@ -54,8 +57,10 @@ public final class GBFS {
         int progressA = Heuristic.lastPushProgress(a);
         int progressB = Heuristic.lastPushProgress(b);
         if (progressA != progressB) {
+            Diagnostics.recordComparatorDecision("progress");
             return Integer.compare(progressB, progressA);
         }
+        Diagnostics.recordComparatorDecision("insertion");
         return Long.compare(a.getInsertionId(), b.getInsertionId());
     };
 
@@ -83,10 +88,12 @@ public final class GBFS {
         long deadline = startTime + TIME_LIMIT_NANOS;
         stats.reset(TIME_LIMIT_NANOS);
         stats.markStart(startTime);
+        Diagnostics.markSearchStart();
 
         long initialSignature = initial.getHash();
         bestCosts.put(initialSignature, encodeCost(initial));
         open.add(initial);
+        Diagnostics.recordOpenSize(open.size());
 
         State bestGoal = initial.isGoal(goalCoordinates) ? initial : null;
         bestFrontierCandidate = initial;
@@ -97,14 +104,22 @@ public final class GBFS {
             if (now > deadline) {
                 break;
             }
+            if (Diagnostics.shouldSample(Diagnostics.getExpandedStates())) {
+                Diagnostics.recordQueueSnapshot(open, stateComparator);
+            }
             State current = open.poll();
             stats.incrementExpanded();
+            Diagnostics.incrementExpanded(current);
+            Diagnostics.checkFirstPush(current, open);
             updateFrontierCandidates(current);
 
             long signature = current.getHash();
             long encoded = encodeCost(current);
             Long recorded = bestCosts.get(signature);
             if (recorded != null && recorded.longValue() != encoded) {
+                if (Diagnostics.ENABLED) {
+                    Diagnostics.recordDuplicateGlobal();
+                }
                 continue;
             }
 
@@ -120,6 +135,7 @@ public final class GBFS {
                         current.getPushes(),
                         bestCosts.size());
                 String plan = current.reconstructPlan();
+                Diagnostics.markSearchFinish(true, false);
                 return new SearchOutcome(plan, true, plan);
             }
 
@@ -139,6 +155,7 @@ public final class GBFS {
                 planState.getDepth(),
                 planState.getPushes(),
                 bestCosts.size());
+        Diagnostics.markSearchFinish(solved, limitHit);
 
         return new SearchOutcome(plan, solved, completePlan);
     }
@@ -256,6 +273,10 @@ public final class GBFS {
                                     int startY,
                                     PriorityQueue<State> open,
                                     Map<Long, Long> bestCosts) {
+        long considerStart = Diagnostics.now();
+        if (Diagnostics.ENABLED) {
+            Diagnostics.recordConsiderPushStart();
+        }
         for (int dir = 0; dir < Constants.DIRECTION_X.length; dir++) {
             int boxX = px + Constants.DIRECTION_X[dir];
             int boxY = py + Constants.DIRECTION_Y[dir];
@@ -280,15 +301,20 @@ public final class GBFS {
             // PRE-PUSH region gate: strict first, then loose fallback
             boolean strictRegionOk = deadlockDetector.regionHasGoalForMove(state.getBoxes(), boxIdx, destX, destY);
             if (!strictRegionOk) {
+                if (Diagnostics.ENABLED) {
+                    Diagnostics.recordPrePrunedStrict();
+                }
                 // fallback to loose connectivity that ignores boxes
                 if (!deadlockDetector.regionHasGoalIgnoringBoxes(destX, destY)) {
                     stats.recordRegionPrePruned();
+                    Diagnostics.recordPrePrunedLooseFail();
                     continue;
                 }
                 int srcD = Heuristic.nearestGoalDistance(boxX, boxY);
                 int dstD = Heuristic.nearestGoalDistance(destX, destY);
                 if (dstD > srcD) {
                     stats.recordRegionPrePruned();
+                    Diagnostics.recordPrePrunedNonWorsen();
                     continue;
                 }
             }
@@ -304,20 +330,24 @@ public final class GBFS {
                 Coordinate movedBox = finalState.getBoxes()[movedIdx];
                 if (!deadlockDetector.regionHasGoalForMove(finalState.getBoxes(), movedIdx, movedBox.x, movedBox.y)) {
                     stats.recordRegionPostPruned();
+                    Diagnostics.recordPostPrunedRegion();
                     continue;
                 }
                 if (deadlockDetector.isWallLineFreeze(movedBox.x, movedBox.y, finalState.getBoxes())) {
                     stats.recordWallLinePruned();
+                    Diagnostics.recordPostPrunedWallLine();
                     continue;
                 }
             }
             long signature = finalState.getHash();
             if (!localSignatureBuffer.add(signature)) {
                 stats.recordDuplicatePruned();
+                Diagnostics.recordDuplicateLocal();
                 continue;
             }
             if (deadlockDetector.isDeadlock(finalState)) {
                 stats.recordDeadlockPruned();
+                Diagnostics.recordPostPrunedDeadlock();
                 continue;
             }
             int heuristic = Heuristic.evaluate(finalState);
@@ -329,12 +359,17 @@ public final class GBFS {
             Long previous = bestCosts.get(signature);
             if (previous != null && !isBetterCost(encodedCost, previous)) {
                 stats.recordDuplicatePruned();
+                Diagnostics.recordDuplicateGlobal();
                 continue;
             }
             bestCosts.put(signature, encodedCost);
             open.add(finalState);
             updateFrontierCandidates(finalState);
             stats.recordEnqueued(open.size());
+            Diagnostics.recordOpenSize(open.size());
+        }
+        if (Diagnostics.ENABLED) {
+            Diagnostics.recordConsiderPushTime(System.nanoTime() - considerStart);
         }
     }
 
diff --git a/src/solver/Heuristic.java b/src/solver/Heuristic.java
index f40edff..1843c08 100644
--- a/src/solver/Heuristic.java
+++ b/src/solver/Heuristic.java
@@ -88,18 +88,34 @@ public final class Heuristic {
 
     public static int evaluate(Coordinate player, Coordinate[] boxes) {
         if (boxes.length == 0 || goalDistanceGrids.length == 0) {
+            if (Diagnostics.ENABLED) {
+                Diagnostics.recordAssignmentValue(0);
+                Diagnostics.recordHeuristicEvaluation(false);
+            }
             return 0;
         }
         int boxCount = boxes.length;
         int goalCount = goalDistanceGrids.length;
         if (goalCount < boxCount) {
+            if (Diagnostics.ENABLED) {
+                Diagnostics.recordAssignmentValue(Integer.MAX_VALUE);
+                Diagnostics.recordHeuristicEvaluation(true);
+            }
             return Integer.MAX_VALUE;
         }
+        long evalStart = Diagnostics.now();
         int assignment = assignmentLowerBound(boxes, boxCount, goalCount);
-        if (assignment >= INF) {
+        boolean inf = assignment >= INF;
+        if (Diagnostics.ENABLED) {
+            int recordedValue = inf ? Integer.MAX_VALUE : assignment;
+            Diagnostics.recordAssignmentValue(recordedValue);
+            Diagnostics.recordHeuristicEvaluation(inf);
+            Diagnostics.noteHeuristicDuration(System.nanoTime() - evalStart);
+        }
+        if (inf) {
             return Integer.MAX_VALUE;
         }
-        int proximity = estimatePlayerProximity(player, boxes);
+        int proximity = Diagnostics.zeroProximity() ? 0 : estimatePlayerProximity(player, boxes);
         return assignment + proximity;
     }
 
@@ -188,17 +204,31 @@ public final class Heuristic {
     }
 
     private static int assignmentLowerBound(Coordinate[] boxes, int boxCount, int goalCount) {
+        long start = Diagnostics.now();
         if (boxCount == 0) {
+            if (Diagnostics.ENABLED) {
+                Diagnostics.recordAssignmentTime(System.nanoTime() - start);
+            }
             return 0;
         }
         if (goalCount == 0) {
+            if (Diagnostics.ENABLED) {
+                Diagnostics.recordAssignmentTime(System.nanoTime() - start);
+            }
             return Integer.MAX_VALUE;
         }
         if (boxCount > goalCount) {
+            if (Diagnostics.ENABLED) {
+                Diagnostics.recordAssignmentTime(System.nanoTime() - start);
+            }
             return Integer.MAX_VALUE;
         }
         if (goalCount <= 15) {
-            return assignWithBitmask(boxes, boxCount, goalCount);
+            int value = assignWithBitmask(boxes, boxCount, goalCount);
+            if (Diagnostics.ENABLED) {
+                Diagnostics.recordAssignmentTime(System.nanoTime() - start);
+            }
+            return value;
         }
         int size = goalCount;
         ensureCostCapacity(size);
@@ -220,10 +250,17 @@ public final class Heuristic {
                 }
             }
             if (!reachable) {
+                if (Diagnostics.ENABLED) {
+                    Diagnostics.recordAssignmentTime(System.nanoTime() - start);
+                }
                 return Integer.MAX_VALUE;
             }
         }
-        return hungarian(reusableCost, size);
+        int result = hungarian(reusableCost, size);
+        if (Diagnostics.ENABLED) {
+            Diagnostics.recordAssignmentTime(System.nanoTime() - start);
+        }
+        return result;
     }
 
     public static int lastPushProgress(State state) {
diff --git a/src/solver/RunSolver.java b/src/solver/RunSolver.java
index bf790fb..9bcb63e 100644
--- a/src/solver/RunSolver.java
+++ b/src/solver/RunSolver.java
@@ -1,5 +1,8 @@
 package solver;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import reader.FileReader;
 import reader.MapData;
 
@@ -8,13 +11,18 @@ public final class RunSolver {
     }
 
     public static void main(String[] args) {
-        if (args.length == 0) {
-            System.err.println("Usage: java -cp out solver.RunSolver <map1> [map2 ...]");
+        List<String> mapNames = new ArrayList<>();
+        boolean anyFail = false;
+        parseArguments(args, mapNames);
+        if (mapNames.isEmpty()) {
+            System.err.println("Usage: java -cp out solver.RunSolver [--diag] [--diag-sample=N] [--diag-no-proximity] <map1> [map2 ...]");
             System.exit(1);
         }
-        boolean anyFail = false;
-        for (String mapName : args) {
+        for (String mapName : mapNames) {
             try {
+                if (Diagnostics.ENABLED) {
+                    Diagnostics.resetForMap(mapName);
+                }
                 FileReader fr = new FileReader();
                 MapData md = fr.readFile(mapName);
                 if (md == null) {
@@ -65,6 +73,8 @@ public final class RunSolver {
                 String plan = bot.solveSokobanPuzzle(md.columns, md.rows, mapData, itemsData);
 
                 SearchStats st = bot.getLastStats();
+                SearchOutcome outcome = bot.getLastOutcome();
+                boolean solved = outcome != null && outcome.bestPlanSolves();
                 int len = (plan == null) ? 0 : plan.length();
                 System.out.println(mapName + " len=" + len
                         + " pushes=" + st.getBestPlanPushes()
@@ -73,6 +83,10 @@ public final class RunSolver {
                         + " postPruned=" + st.getRegionPostPruned()
                         + " wallLine=" + st.getWallLinePruned());
 
+                if (Diagnostics.ENABLED) {
+                    Diagnostics.emitDiagnostics(st.getElapsedMillis(), solved, st.isTimeLimitHit(), st.getClosedStates());
+                }
+
                 if (len == 0) {
                     anyFail = true;
                 }
@@ -85,4 +99,32 @@ public final class RunSolver {
             System.exit(2);
         }
     }
+
+    private static void parseArguments(String[] args, List<String> mapNames) {
+        boolean diagEnabled = false;
+        for (String arg : args) {
+            if ("--diag".equals(arg)) {
+                diagEnabled = true;
+                continue;
+            }
+            if (arg.startsWith("--diag-sample=")) {
+                diagEnabled = true;
+                String value = arg.substring("--diag-sample=".length());
+                try {
+                    int parsed = Integer.parseInt(value);
+                    Diagnostics.SAMPLE_MASK = Math.max(0, parsed);
+                } catch (NumberFormatException ignore) {
+                    System.err.println("Invalid --diag-sample value: " + value);
+                }
+                continue;
+            }
+            if ("--diag-no-proximity".equals(arg)) {
+                diagEnabled = true;
+                Diagnostics.ZERO_PROXIMITY = true;
+                continue;
+            }
+            mapNames.add(arg);
+        }
+        Diagnostics.ENABLED = diagEnabled;
+    }
 }
diff --git a/src/solver/SokoBot.java b/src/solver/SokoBot.java
index d5ad8f2..f3bceaa 100644
--- a/src/solver/SokoBot.java
+++ b/src/solver/SokoBot.java
@@ -12,12 +12,14 @@ public class SokoBot {
     private final List<Coordinate> boxList = new ArrayList<>();
     private final List<Coordinate> goalList = new ArrayList<>();
     private SearchStats lastStats = SearchStats.empty();
+    private SearchOutcome lastOutcome = null;
     private static final int SMALL_PUZZLE_BOX_LIMIT = 4;
 
     public String solveSokobanPuzzle(int width, int height, char[][] mapData, char[][] itemsData) {
         player = null;
         boxList.clear();
         goalList.clear();
+        lastOutcome = null;
 
         extractMap(mapData, itemsData, height, width);
 
@@ -27,6 +29,7 @@ public class SokoBot {
         String bfsPlan = trySolveSmallPuzzle(mapData, boxes, player, goals);
         if (bfsPlan != null) {
             lastStats = SearchStats.empty();
+            lastOutcome = new SearchOutcome(bfsPlan, true, bfsPlan);
             return bfsPlan;
         }
 
@@ -36,6 +39,7 @@ public class SokoBot {
         GBFS solver = new GBFS(mapData, goals);
         SearchOutcome outcome = solver.search(initial);
         lastStats = solver.getStatistics();
+        lastOutcome = outcome;
 
         String planToReturn = outcome.getBestPlan();
         ReplayValidator.ValidationResult validation = ReplayValidator.validate(mapData, itemsData, planToReturn);
@@ -90,6 +94,10 @@ public class SokoBot {
         return lastStats;
     }
 
+    public SearchOutcome getLastOutcome() {
+        return lastOutcome;
+    }
+
     private String trySolveSmallPuzzle(char[][] mapData, Coordinate[] boxes, Coordinate player, Coordinate[] goals) {
         if (boxes.length == 0) {
             return "";
